<!-- Then put toasts within -->
<!-- Контейнеры для разных позиций будут созданы автоматически через JavaScript -->  
<div class="toast-container position-absolute top-0 end-0 p-3">  
  <!-- Здесь будут отображаться уведомления -->  
</div>

<div id="overlay" class="overlay">
  <div class="spinner-container">
    <div class="spinner-border text-primary" role="status">
      <span class="visually-hidden">Loading...</span>
    </div>
    <div class="overlay-text">
      Loading...
    </div>
  </div>
</div>

<style>
  .overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.3);
    z-index: 9999;
    justify-content: center;
    align-items: center;
    flex-direction: column;
  }

  .spinner-container {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .spinner-border {
    width: 7rem;
    height: 7rem;
  }

  .overlay-text {
    position: absolute;
    color: white;
    font-size: 1rem;
  }
</style>

<script src="{{ config.ASSETS_ROOT }}/plugins/socket.io/socket.io.js"></script>
<script>
  var socket = io.connect(window.location.protocol + '//' + document.domain + ':' + location.port);

  socket.on('connect', function () {
    console.log('Connected to server');
    document.getElementById('overlay').style.display = 'none';
    subscribe();
  });

  socket.on('disconnect', function () {
    console.log('Disconnected from server');
    document.getElementById('overlay').style.display = 'flex';
  });

  socket.on('message', function (msg) {
    var messages = document.getElementById('messages');
    var message = document.createElement('div');
    message.textContent = msg;
    messages.appendChild(message);
  });

  socket.on('changeProperty', function (msg) {
    var elements = document.querySelectorAll(`[id^="prop:${msg.property}"]`);
    elements.forEach(element => {
      if (element.id === `prop:${msg.property}`)
        element.textContent = typeof msg.value === "object" ? JSON.stringify(msg.value) : msg.value;
    });
    elements = document.querySelectorAll(`[id^="prop_changed:${msg.property}"]`);
    elements.forEach(element => {
      if (element.id === `prop_changed:${msg.property}`)
        element.textContent = msg.changed;
    });
    elements = document.querySelectorAll(`[id^="prop_source:${msg.property}"]`);
    elements.forEach(element => {
      if (element.id === `prop_source:${msg.property}`)
        element.textContent = msg.source;
    });
  });
  socket.on('executedMethod', function (msg) {
    var elements = document.querySelectorAll(`[id^="method_source:${msg.method}"]`);
    elements.forEach(element => {
      if (element.id === `method_source:${msg.method}`)
        element.textContent = msg.source;
    });
    elements = document.querySelectorAll(`[id^="method_executed:${msg.method}"]`);
    elements.forEach(element => {
      if (element.id === `method_executed:${msg.method}`)
        element.textContent = msg.executed;
    });
    elements = document.querySelectorAll(`[id^="method_exec_params:${msg.method}"]`);
    elements.forEach(element => {
      if (element.id === `method_exec_params:${msg.method}`)
        element.textContent = msg.exec_params;
    });
    elements = document.querySelectorAll(`[id^="method_exec_result:${msg.method}"]`);
    elements.forEach(element => {
      if (element.id === `method_exec_result:${msg.method}`)
        element.textContent = msg.exec_result;
    });
    elements = document.querySelectorAll(`[id^="method_exec_time:${msg.method}"]`);
    elements.forEach(element => {
      if (element.id === `method_exec_time:${msg.method}`)
        element.textContent = msg.exec_time;
    });
  });
  socket.on('changeObject', function (msg) {
    console.log("change objects", msg)
    var element = document.getElementById("obj:" + msg.object);
    if (element) {
      element.innerHTML = msg.value;
    }
    else
      console.log("not found object")
  });

  function formatTime(number) {
    return number < 10 ? '0' + number : number;
  }

  // Функция для отображения уведомлений
  // Заменить функцию showNotification на:  
  function showNotification(data) {
    notificationManager.show(data);
  }

  // Обработка события при получении уведомления от сервера 
  socket.on('say', function (data) {
    console.log("SAY", data);

    var ext = data.args || {}

    const options = {
      groupKey: ext.source || null,
      sound: ext.sound || ext.level === 'error' || ext.level === 'warning',
      persistent: ext.persistent || ext.level === 'error',
      actions: []
    };

    if (ext.source) {
      options.actions.push({
        id: 'view_logs',
        label: 'Open',
        callback: (notifId, actionId) => {
          window.open(`/admin/${ext.source}`, '_blank');
        }
      });
    }

    notificationManager.show({
      level: ext.level || 'info',
      message: data.message,
      title: ext.title || 'Системное уведомление'
    }, options);
  });

  socket.on('playsound', function (data) {
    console.log("playsound", data);
    if (typeof playSound === 'function') {  
      playSound(data.file_url);  
    }  
  });

  function restart_system() {
    socket.emit('restart_system');
  }

  function setProperty(name, value) {
    socket.emit('setProperty', name, value);
  }

  function callMethod(name) {
    socket.emit('callMethod', name);
  }

  function callMethodWithResult(name) {
    socket.emit('callMethod', name, "WS", true);
  }

  // Функция для обновления блока уведомлений (определяем здесь, чтобы она была доступна всегда)
  function refreshNotifyBlockIfAvailable(source) {
    // Проверяем, находимся ли мы на странице модуля
    const currentPath = window.location.pathname;
    const pathParts = currentPath.split('/').filter(function(part) { return part !== ''; });
    const currentSource = pathParts[pathParts.length - 1];
    
    const isOnModulePage = source && (
      currentSource === source || 
      currentPath.includes('/admin/' + source) ||
      currentPath.endsWith('/' + source) ||
      currentPath.endsWith('/admin/' + source)
    );
    
    if (!isOnModulePage) {
      return false;
    }
    
    // Пытаемся вызвать функцию, если она определена
    if (typeof refreshNotifyBlock === 'function') {
      refreshNotifyBlock(source);
      return true;
    } else {
      return false;
    }
  }

  // Обработка событий уведомлений
  socket.on('notify', function (data) {
    if (!data || !data.operation || !data.data) return;
    
    if (data.operation === 'new_notify') {
      const notifySource = data.data.source;
      
      // Обновляем индикаторы уведомлений
      if (typeof updateNotificationIndicators === 'function') {
        updateNotificationIndicators();
      }
      
      // Пытаемся обновить блок уведомлений
      // Небольшая задержка для гарантии, что функция определена
      setTimeout(function() {
        if (!refreshNotifyBlockIfAvailable(notifySource)) {
          // Если функция еще не определена, ждем и повторяем попытку
          let retryCount = 0;
          const maxRetries = 15;
          const retryInterval = setInterval(function() {
            retryCount++;
            if (refreshNotifyBlockIfAvailable(notifySource)) {
              clearInterval(retryInterval);
            } else if (retryCount >= maxRetries) {
              clearInterval(retryInterval);
            }
          }, 200);
        }
      }, 100); // Небольшая задержка для гарантии, что функция определена
    } else if (data.operation === 'read_notify') {
      // Уведомление было прочитано на другой странице или на этой же
      const notifyId = data.data.id;
      const notifySource = data.data.source;
      
      // Удаляем уведомление из блока на текущей странице
      // Ищем элемент несколькими способами для надежности
      let alertElement = $('button[onclick*="readNotify(' + notifyId + ')"]').closest('.alert');
      
      // Если не нашли по onclick, ищем по data-атрибуту или другим способам
      if (alertElement.length === 0) {
        // Пытаемся найти через data-атрибут (если он есть)
        alertElement = $('.alert[data-notify-id="' + notifyId + '"]');
      }
      
      if (alertElement.length) {
        alertElement.fadeOut(300, function() {
          $(this).remove();
          // Проверяем, остались ли еще уведомления
          const notifyBlock = $('#notify_block');
          if (notifyBlock.length) {
            const remainingAlerts = notifyBlock.find('.alert');
            if (remainingAlerts.length === 0) {
              // Если уведомлений не осталось, скрываем весь блок
              notifyBlock.fadeOut(300, function() {
                $(this).remove();
              });
            } else {
              // Обновляем счетчик уведомлений
              const countElement = notifyBlock.find('.px-3.me-auto');
              const notifyText = 'Уведомления';
              if (countElement.length) {
                countElement.html(notifyText + ' - ' + remainingAlerts.length);
              } else {
                notifyBlock.find('h5 .px-3.me-auto').html(notifyText + ' - ' + remainingAlerts.length);
              }
            }
          }
        });
      } else if (notifySource) {
        // Если элемент не найден, но есть source, обновляем весь блок
        // Это может быть, если уведомление было удалено до обновления страницы
        if (typeof refreshNotifyBlockIfAvailable === 'function') {
          refreshNotifyBlockIfAvailable(notifySource);
        }
      }
      
      // Обновляем индикаторы уведомлений
      if (typeof updateNotificationIndicators === 'function') {
        updateNotificationIndicators();
      }
    } else if (data.operation === 'read_notify_all') {
      // Все уведомления были прочитаны на другой странице
      const notifySource = data.data.source;
      
      // Проверяем, находимся ли мы на странице модуля
      const currentPath = window.location.pathname;
      const pathParts = currentPath.split('/').filter(function(part) { return part !== ''; });
      const currentSource = pathParts[pathParts.length - 1];
      
      const isOnModulePage = notifySource && (
        currentSource === notifySource || 
        currentPath.includes('/admin/' + notifySource) ||
        currentPath.endsWith('/' + notifySource) ||
        currentPath.endsWith('/admin/' + notifySource)
      );
      
      if (isOnModulePage) {
        const notifyBlock = $('#notify_block');
        if (notifyBlock.length) {
          // Плавно скрываем все уведомления
          const alerts = notifyBlock.find('.alert');
          if (alerts.length > 0) {
            alerts.fadeOut(300, function() {
              $(this).remove();
              // Проверяем, все ли уведомления удалены
              const remainingAlerts = notifyBlock.find('.alert');
              if (remainingAlerts.length === 0) {
                // Скрываем весь блок после удаления всех уведомлений
                notifyBlock.fadeOut(300, function() {
                  $(this).remove();
                });
              }
            });
          } else {
            // Если уведомлений нет, сразу скрываем блок
            notifyBlock.fadeOut(300, function() {
              $(this).remove();
            });
          }
        }
      }
      
      // Обновляем индикаторы уведомлений
      if (typeof updateNotificationIndicators === 'function') {
        updateNotificationIndicators();
      }
    }
  });

  function subscribe() {
    socket.emit('subscribeActions', ['say','playsound']);
    // Подписываемся на события уведомлений
    socket.emit('subscribeData', ['notify']);
    var elements = document.querySelectorAll('[id^="prop:"]');
    var propList = [];
    elements.forEach(function (element) {
      var idWithoutProp = element.id.slice(5); // cut "prop:"
      propList.push(idWithoutProp);
    });
    console.log(propList);
    elements = document.querySelectorAll('[id^="obj:"]');
    var objectList = [];
    elements.forEach(function (element) {
      var idWithoutProp = element.id.slice(4); // cut "prop:"
      objectList.push(idWithoutProp);
    });
    console.log(objectList);
    // subscribe
    if (propList.length > 0)
      socket.emit('subscribeProperties', propList);
    if (objectList.length > 0)
      socket.emit('subscribeObjects', objectList);
  }

  document.addEventListener('DOMContentLoaded', function () {
    subscribe()
  });
</script>